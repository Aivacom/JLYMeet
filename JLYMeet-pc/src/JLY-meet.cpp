#include "stdafx.h"
#include "JLY-meet.h"
#include "JLY-meetDlg.h"
#include "CrashReport.h"
#include "msjexhnd.h"
#include "base\LoggerExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

extern  CString g_demoVer = _T("2.8.0-meet-5");
static const CString g_CrashLogFile = _T("JLY-meet-Crash.txt");

// CJLYVideoDemoApp

BEGIN_MESSAGE_MAP(CJLYVideoDemoApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()

CJLYVideoDemoApp::CJLYVideoDemoApp()
{
	// support restart manager
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;
}

////////////////////////////////////////////////
// CJLYVideoDemoApp object
CJLYVideoDemoApp theApp;

BOOL CJLYVideoDemoApp::InitInstance()
{
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
	// If an application manifest running on Windows XP specifies that ComCtl32.dll version 6 or later is to be used to enable visualization.
	// InitCommonControlsEx() is required.Otherwise, the window cannot be created.
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	
	// Set it to include all common control classes to be used in the application.
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();

	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	// Create a shell manager in case the dialog box contains any shell tree view control or shell list view control.
	CShellManager *pShellManager = new CShellManager;

	// Activate the "Windows Native" visual manager to enable themes in the MFC control
	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	// Standard initialization.
	// If you do not use these features and want to reduce the size of the final executable file, 
	// you should remove the following specific initialization routines that are not required to change the registry key used to store the settings
	// TODO: The string should be modified appropriately,
	// For example, change to company or organization name
	SetRegistryKey(_T("Local application generated by the application wizard"));

	initCrashReport();

	mPostOffice.SetNotice(NULL, WM_HTTP_CMD);

	MSJExceptionHandler dmpHandle;

	CJLYMeetDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: When to put processing here
		// "OK" to close the dialog code
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: When to put processing here
		// "Cancel" to close the dialog code
	}
	else if (nResponse == -1)
	{
		TRACE(traceAppMsg, 0, "Warning: The dialog creation failed and the application will terminate unexpectedly.\n");
		TRACE(traceAppMsg, 0, "Warning: If you use MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS. \n");
	}

	// Delete the shell manager created above.
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}

#ifndef _AFXDLL
	ControlBarCleanUp();
#endif

	// Since the dialog is closed, it will return FALSE to exit the application,
	// Instead of starting the application's message pump.
	return FALSE;
}

CPostoffice & CJLYVideoDemoApp::getPostOffice()
{
	return mPostOffice;
}

void CJLYVideoDemoApp::initCrashReport()
{
	// Create crash report log
	CString moduledir = GetModuleDir();
	CString logPath = moduledir + _T("\\") + g_CrashLogFile;
	CreateFile(g_CrashLogFile, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (!moduledir.IsEmpty())
		CrashReport::SetDllPath(moduledir);

	CrashReport::InitBugReport(_T("JLYMeet-pc"), g_demoVer, _T("JLYMeet-pc"));
	CrashReport::SetProductVerDetail(_T("2020/01/08, LanPZzzz use test demo"));
	CrashReport::SetCatchPureCall(TRUE);
	CrashReport::AddCustomReportFile(logPath);
}

CString CJLYVideoDemoApp::GetModuleDir()
{
	HMODULE module = GetModuleHandle(0);
	CString strPath;
	GetModuleFileName(module, strPath.GetBufferSetLength(MAX_PATH + 1), MAX_PATH + 1);
	int nPos = strPath.ReverseFind(_T('\\'));
	if (nPos < 0)
		return CString("");
	else
		return strPath.Left(nPos);
}
